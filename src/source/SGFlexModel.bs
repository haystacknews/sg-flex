class SGFlexModel
    private logger as dynamic

    private width as float
    private height as float

    ' See enums at the bottom of this file
    private direction as string
    private justifyContent as string
    private alignItems as string

    private mainAxis as string
    private crossAxis as string
    private mainDimension as string
    private crossDimension as string

    private childrenBoundingRects as object
    private childrenAccWidth as float
    private childrenAccHeight as float
    private childrenMaxHeight as float
    private childrenMaxWidth as float

    sub new(childrenBoundingRects as object, _args = {} as object, logger = invalid as dynamic)
        m.logger = logger

        m.childrenBoundingRects = childrenBoundingRects

        args = {
            width: -1,
            height: -1,
            ' TODO: Remove disables when bslint stops complaining about unused variables for enums.
            ' bs:disable-next-line
            direction: Direction.row,
            ' bs:disable-next-line
            justifyContent: JustifyContent.flexStart,
            ' bs:disable-next-line
            alignItems: AlignItems.flexStart
        }

        for each key in _args.keys()
            args[key] = _args[key]
        end for

        m.validateArgs(args)

        m.direction = args.direction
        m.justifyContent = args.justifyContent
        m.alignItems = args.alignItems

        ' bs:disable-next-line
        if (m.direction = Direction.row)
            ' bs:disable-next-line
            m.mainAxis = Axis.x
            ' bs:disable-next-line
            m.crossAxis = Axis.y
            ' bs:disable-next-line
            m.mainDimension = Dimension.width
            ' bs:disable-next-line
            m.crossDimension = Dimension.height
        else
            ' bs:disable-next-line
            m.mainAxis = Axis.y
            ' bs:disable-next-line
            m.crossAxis = Axis.x
            ' bs:disable-next-line
            m.mainDimension = Dimension.height
            ' bs:disable-next-line
            m.crossDimension = Dimension.width
        end if

        m.childrenAccWidth = 0
        m.childrenAccHeight = 0
        m.childrenMaxWidth = 0
        m.childrenMaxHeight = 0
        for each childRect in childrenBoundingRects
            m.childrenAccWidth += childRect.width
            m.childrenAccHeight += childRect.height

            if (m.childrenMaxWidth < childRect.width)
                m.childrenMaxWidth = childRect.width
            end if

            if (m.childrenMaxHeight < childRect.height)
                m.childrenMaxHeight = childRect.height
            end if
        end for

        if (args.width < 0)
            m.width = m.childrenAccWidth
        else
            m.width = args.width
        end if

        if (args.height < 0)
            m.height = m.childrenAccHeight
        else
            m.height = args.height
        end if
    end sub

    function getWidth() as float
        return m.width
    end function

    function getHeight() as float
        return m.height
    end function

    sub setWidth(width as float)
        m.width = width
    end sub

    sub setHeight(height as float)
        m.height = height
    end sub

    sub setChildrenBoundingRects(childrenBoundingRects as object)
        m.childrenBoundingRects = childrenBoundingRects
    end sub

    ' /**
    '  * Returns a list of translations to apply to each original child at the given index
    '  * to position them according to the `direction`, `justifyContent` and `alignItems` values.
    '  * @returns { childIndex as integer, x as float, y as float }[]
    ' */
    public function getTranslations() as object
        translations = []

        ' Main axis translations
        ' bs:disable-next-line
        if (m.justifyContent = JustifyContent.flexStart)

            ' bs:disable-next-line
        else if (m.justifyContent = JustifyContent.flexEnd)

            ' bs:disable-next-line
        else if (m.justifyContent = JustifyContent.center)

            ' bs:disable-next-line
        else if (m.justifyContent = JustifyContent.spaceBetween)
            if (m.childrenBoundingRects.count() > 1)
                ' SB = (P_w - max(C_h)) / (n - 1)
                spaceBetween = m[m.mainDimension]
                accDimension = 0
                ' bs:disable-next-line
                if (m.direction = Direction.row)
                    accDimension = m.childrenAccWidth
                else
                    accDimension = m.childrenAccHeight
                end if
                spaceBetween -= accDimension
                spaceBetween /= m.childrenBoundingRects.count() - 1

                for i = 1 to m.childrenBoundingRects.count() - 1
                    prevTranslation = translations[translations.count() - 1]
                    prevChild = m.childrenBoundingRects[i - 1]

                    if (prevTranslation = invalid)
                        prevTranslation = { x: prevChild.x, y: prevChild.y }
                    end if

                    ' Translation formula (change "x" to "y" and "w" to "h" for direction = column)
                    ' T(n)_x = T(n-1)_x + C(n-1)_w + SB + (C(n-1)_x * -1)
                    ' We consider the last term to account for children
                    ' whose center of coordinates is not the top left of their boundingRect.
                    ' For example, children that are `LayoutGroup`s with `horizAlignment` = "center"
                    translatedMainAxis = prevTranslation[m.mainAxis]
                    translatedMainAxis += prevChild[m.mainDimension]
                    translatedMainAxis += spaceBetween
                    translatedMainAxis += m.childrenBoundingRects[i].[m.mainAxis] * -1

                    translation = { childIndex: i }
                    translation[m.mainAxis] = translatedMainAxis
                    translation[m.crossAxis] = m.childrenBoundingRects[i][m.crossAxis]

                    translations.push(translation)
                end for
            end if
            ' bs:disable-next-line
        else if (m.justifyContent = JustifyContent.spaceAround)

            ' bs:disable-next-line
        else if (m.justifyContent = JustifyContent.spaceEvenly)

        end if

        ' Cross axis translations
        ' bs:disable-next-line
        if (m.alignItems = AlignItems.flexStart)

            ' bs:disable-next-line
        else if (m.alignItems = AlignItems.flexEnd)

            ' bs:disable-next-line
        else if (m.alignItems = AlignItems.center)
            for i = 0 to m.childrenBoundingRects.count() - 1
                translatedCrossAxis = (m[m.crossDimension] - m.childrenBoundingRects[i][m.crossDimension]) / 2
                translatedCrossAxis += m.childrenBoundingRects[i][m.crossAxis] * -1

                existingTranslationIndex = -1

                for j = 0 to translations.count() - 1
                    if (translations[j].childIndex = i)
                        existingTranslationIndex = j
                        exit for
                    end if
                end for

                if (existingTranslationIndex <> -1)
                    translations[existingTranslationIndex][m.crossAxis] = translatedCrossAxis
                else
                    translation = { childIndex: i }
                    translation[m.mainAxis] = m.childrenBoundingRects[i][m.mainAxis]
                    translation[m.crossAxis] = translatedCrossAxis
                    translations.push(translation)
                end if
            end for
        end if

        return translations
    end function

    private sub validateArgs(args as object)
        ' bs:disable-next-line
        if ((args.direction <> Direction.row) and (args.direction <> Direction.column))
            if (m.logger <> invalid)
                ' bs:disable-next-line
                m.logger.error(ErrorCode.invalidDirection, args.direction)
            end if
        end if

        ' bs:disable-next-line
        if ((args.justifyContent <> JustifyContent.flexStart) and (args.justifyContent <> JustifyContent.flexEnd) and (args.justifyContent <> JustifyContent.center) and (args.justifyContent <> JustifyContent.spaceBetween) and (args.justifyContent <> JustifyContent.spaceAround) and (args.justifyContent <> JustifyContent.spaceEvenly))
            if (m.logger <> invalid)
                ' bs:disable-next-line
                m.logger.error(ErrorCode.invalidJustifyContent, args.justifyContent)
            end if
        end if

        ' bs:disable-next-line
        if ((args.alignItems <> AlignItems.flexStart) and (args.alignItems <> AlignItems.flexEnd) and (args.alignItems <> AlignItems.center))
            if (m.logger <> invalid)
                ' bs:disable-next-line
                m.logger.error(ErrorCode.invalidAlignItems, args.alignItems)
            end if
        end if
    end sub
end class

enum Direction
    row = "row"
    column = "column"
end enum

enum JustifyContent
    flexStart = "flexStart"
    flexEnd = "flexEnd"
    center = "center"
    spaceBetween = "spaceBetween"
    spaceAround = "spaceAround"
    spaceEvenly = "spaceEvenly"
end enum

enum AlignItems
    flexStart = "flexStart"
    flexEnd = "flexEnd"
    center = "center"
    ' The values `stretch` and `baseline` are not really possible since
    ' we can't modify the size of the children or inspect their contents.
end enum

enum Axis
    x = "x"
    y = "y"
end enum

enum Dimension
    width = "width"
    height = "height"
end enum

enum ErrorCode
    invalidDirection = "Invalid `direction` value."
    invalidJustifyContent = "Invalid `justifyContent` value."
    invalidAlignItems = "Invalid `alignItems` value."
end enum
